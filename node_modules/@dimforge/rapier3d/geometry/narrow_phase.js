import { RawNarrowPhase } from "../raw";
import { VectorOps } from "../math";
/**
 * The narrow-phase used for precise collision-detection.
 *
 * To avoid leaking WASM resources, this MUST be freed manually with `narrowPhase.free()`
 * once you are done using it.
 */
var NarrowPhase = /** @class */ (function () {
    function NarrowPhase(raw) {
        this.raw = raw || new RawNarrowPhase();
        this.tempManifold = new TempContactManifold(null);
    }
    /**
     * Release the WASM memory occupied by this narrow-phase.
     */
    NarrowPhase.prototype.free = function () {
        this.raw.free();
        this.raw = undefined;
    };
    /**
     * Enumerates all the colliders potentially in contact with the given collider.
     *
     * @param collider1 - The second collider involved in the contact.
     * @param f - Closure that will be called on each collider that is in contact with `collider1`.
     */
    NarrowPhase.prototype.contactsWith = function (collider1, f) {
        this.raw.contacts_with(collider1, f);
    };
    /**
     * Enumerates all the colliders intersecting the given colliders, assuming one of them
     * is a sensor.
     */
    NarrowPhase.prototype.intersectionsWith = function (collider1, f) {
        this.raw.intersections_with(collider1, f);
    };
    /**
     * Iterates through all the contact manifolds between the given pair of colliders.
     *
     * @param collider1 - The first collider involved in the contact.
     * @param collider2 - The second collider involved in the contact.
     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument
     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`
     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.
     */
    NarrowPhase.prototype.contactPair = function (collider1, collider2, f) {
        var rawPair = this.raw.contact_pair(collider1, collider2);
        if (!!rawPair) {
            var flipped = rawPair.collider1() != collider1;
            var i = void 0;
            for (i = 0; i < rawPair.numContactManifolds(); ++i) {
                this.tempManifold.raw = rawPair.contactManifold(i);
                if (!!this.tempManifold.raw) {
                    f(this.tempManifold, flipped);
                }
                // SAFETY: The RawContactManifold stores a raw pointer that will be invalidated
                //         at the next timestep. So we must be sure to free the pair here
                //         to avoid unsoundness in the Rust code.
                this.tempManifold.free();
            }
            rawPair.free();
        }
    };
    /**
     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.
     * @param collider1 − The first collider involved in the intersection.
     * @param collider2 − The second collider involved in the intersection.
     */
    NarrowPhase.prototype.intersectionPair = function (collider1, collider2) {
        return this.raw.intersection_pair(collider1, collider2);
    };
    return NarrowPhase;
}());
export { NarrowPhase };
var TempContactManifold = /** @class */ (function () {
    function TempContactManifold(raw) {
        this.raw = raw;
    }
    TempContactManifold.prototype.free = function () {
        this.raw.free();
        this.raw = undefined;
    };
    TempContactManifold.prototype.normal = function () {
        return VectorOps.fromRaw(this.raw.normal());
    };
    TempContactManifold.prototype.localNormal1 = function () {
        return VectorOps.fromRaw(this.raw.local_n1());
    };
    TempContactManifold.prototype.localNormal2 = function () {
        return VectorOps.fromRaw(this.raw.local_n2());
    };
    TempContactManifold.prototype.subshape1 = function () {
        return this.raw.subshape1();
    };
    TempContactManifold.prototype.subshape2 = function () {
        return this.raw.subshape2();
    };
    TempContactManifold.prototype.numContacts = function () {
        return this.raw.num_contacts();
    };
    TempContactManifold.prototype.localContactPoint1 = function (i) {
        return VectorOps.fromRaw(this.raw.contact_local_p1(i));
    };
    TempContactManifold.prototype.localContactPoint2 = function (i) {
        return VectorOps.fromRaw(this.raw.contact_local_p2(i));
    };
    TempContactManifold.prototype.contactDist = function (i) {
        return this.raw.contact_dist(i);
    };
    TempContactManifold.prototype.contactFid1 = function (i) {
        return this.raw.contact_fid1(i);
    };
    TempContactManifold.prototype.contactFid2 = function (i) {
        return this.raw.contact_fid2(i);
    };
    TempContactManifold.prototype.contactImpulse = function (i) {
        return this.raw.contact_impulse(i);
    };
    // #if DIM3
    TempContactManifold.prototype.contactTangentImpulseX = function (i) {
        return this.raw.contact_tangent_impulse_x(i);
    };
    TempContactManifold.prototype.contactTangentImpulseY = function (i) {
        return this.raw.contact_tangent_impulse_y(i);
    };
    // #endif
    TempContactManifold.prototype.numSolverContacts = function () {
        return this.raw.num_solver_contacts();
    };
    TempContactManifold.prototype.solverContactPoint = function (i) {
        return VectorOps.fromRaw(this.raw.solver_contact_point(i));
    };
    TempContactManifold.prototype.solverContactDist = function (i) {
        return this.raw.solver_contact_dist(i);
    };
    TempContactManifold.prototype.solverContactFriction = function (i) {
        return this.raw.solver_contact_friction(i);
    };
    TempContactManifold.prototype.solverContactRestitution = function (i) {
        return this.raw.solver_contact_restitution(i);
    };
    TempContactManifold.prototype.solverContactTangentVelocity = function (i) {
        return VectorOps.fromRaw(this.raw.solver_contact_tangent_velocity(i));
    };
    return TempContactManifold;
}());
export { TempContactManifold };
//# sourceMappingURL=narrow_phase.js.map